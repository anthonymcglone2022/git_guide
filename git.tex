\documentclass[12pt,a4paper]{report}

\usepackage[margin=1in]{geometry}
\usepackage{lipsum}
\usepackage{times}
\usepackage{listings}
\usepackage{hyperref}


\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\renewcommand{\contentsname}{Table of Contents}

\usepackage{titletoc}

\newcommand{\setupname}[1][\chaptername]{
\titlecontents{chapter}[0pt]{\vspace{1ex}}{\bfseries#1~\thecontentslabel:\quad}{\bfseries}{\bfseries\hfill\contentspage}[]
}

\author{Anthony McGlone}\title{Git - Command Line Guide}
\begin{document}\maketitle

\tableofcontents

\setupname
\chapter{Introduction}
\section{What is Git?}

Git is a repository which is used to store files. Git is used by Software Engineers to store and version code for software releases. It's a powerful tool for collaborating on large projects.
\newline
\newline
Git versions the files within its repository, so every time a commit operation is made, the files in the repository are saved - a unique ID is also created and associated with the commit. This means that you can see the history of the changes in the repository. You can also delete the changes in the repository by going back to a specific commit.
\newline
\newline
In this guide you will see how the command line tool \texttt{git} is used to manage this repository.  

\section{Installing Git}
\subsection{MacOS}

1. Open a terminal. Then install Homebrew (steps located: \href{https://brew.sh/}{here}).
\newline
2. Install Git by running \texttt{brew install git}
\newline
3. Open a terminal and run \texttt{git --version} (if Git is installed, the version number should be printed to console) 

\subsection{Windows}

1. Install Git by downloading the Windows binary from git-scm (\href{https://git-scm.com/}{here})
\newline
2. Run the installer
\newline
3. Open a Git Bash terminal and run \texttt{git --version} (if Git is installed, the version number should be printed to console)


\subsection{Linux (Ubuntu)}

1. Install Git by opening a terminal and running \texttt{sudo apt-get install git}
\newline
2. Run \texttt{git --version} (if Git is installed, the version number should be printed to console)


\subsection{Linux (Red Hat)}


1. Install git by opening a terminal and running \texttt{sudo yum install git} 
\newline
2. Run \texttt{git --version} (if Git is installed, the version number should be printed to console)


\chapter{Basic Git command line operations}
\section{Setting up a local repository}
First create a folder called \texttt{store}. Then open a terminal and navigate into that folder. Run this command:
\newline
\newline
\centerline{\texttt{git init}}
\newline
\newline
This command creates the repository and also creates a \texttt{.git}  subdirectory. This subdirectory stores information about commits, and the location of your remote repository. This remote repository is stored on a server (hosted on the internet or on a company's internal network). To share your commits with others, you have to push your local commits to the remote repository. We'll set up the remote repository later.
\newline
\newline
Let's add your username and email to your local repository now. This will be required so your commits can be associated with you. Start with the username. Run the following command (before doing so, add your full name between the quotes in the command below):
\newline
\newline
\centerline{\texttt{git config --global user.name "INSERT NAME HERE"}}
\newline
\newline
Now run the command to set up your email (again, insert your email address between the quotes):
\newline
\newline
\centerline{\texttt{git config --global user.email "INSERT EMAIL HERE"}}
\newline
\newline
Now run the command \texttt{git config --global user.name}. If everything is correct, you should see your username. Run \texttt{git config --global user.email} to see if your email prints out to console.
\newline
\newline
Run the following command to verify that your local repository was set up:
\newline
\newline
\centerline{\texttt{git status}}
\newline
\newline
You should see the following text in your terminal:
\newline
\newline
\newline
\texttt{
On branch master
\\
\\
No commits yet
\\
\\
nothing to commit (create/copy files and use "git add" to track)
}
\newline
That's it! Your local repository is now successfully set up. The branch \texttt{master} is the main branch in your local repository. By default, it's the place where your files are stored. You can create other branches (basically copies of \texttt{master}) and work on edits there before saving them back into the \texttt{master} branch. For now, we'll just work with the \texttt{master} branch. We'll cover branching strategies and remote branches (stored in a remote repository) later.


\section{Committing files into the \texttt{store} repository}

First, create a \texttt{code.txt} file in the \texttt{store} folder. Then run \texttt{git status} in your terminal. You should see the following output:
\newline
\newline
\texttt{
Untracked files:
\\
\hspace*{10mm}(use "git add <file>..." to include in what will be committed)
\\
\\
\hspace*{20mm}code.txt
}
\newline
\newline
The file is untracked, meaning Git doesn't see it yet. If you tried to do a commit operation now, Git wouldn't save the file or version it. Run the add operation below in your terminal to get Git to track the file. 
\newline
\newline
\centerline{\texttt{git add code.txt}}
\newline
\newline
Now run \texttt{git status} again to see the tracking:
\newline
\newline
\texttt{
On branch master
\\
\\
No commits yet
\\
\\
Changes to be committed:
\\
\hspace*{10mm}(use "git rm --cached <file>..." to unstage)
\\
\\
\hspace*{20mm}new file:   code.txt
}
\newline
\newline
Now commit these changes by running \texttt{git commit -m "This is my first commit!"} You can run \texttt{git log} after to see the commit ID. It should look something similar to this:
\newline
\newline
\texttt{
commit b973b70df3ffcfd8dbe0284c76e0d3bd7c30f3b6 (HEAD -> master)
\\
Author: anthonymcglone2022 <anthonymcglone2022@gmail.com>
\\
Date:   Wed May 11 20:14:36 2022 +0100
\\
\\
\hspace*{10mm}This is my first commit!
}
\newline
\newline
\section{Creating a remote repository}
GitHub is a website that offers free hosting of remote Git repositories. In order to create a repository there, there are a few steps that have to be completed. 
\newline

- Signup to GitHub: \href{https://github.com/signup}{here} 

- Generate an SSH key: \href{https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent}{Procedure here (select one of Mac, Linux, Windows)}

- Adding that SSH key into GitHub: \href{https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account}{Procedure}

- Create a repository (name it \texttt{store} and skip the README initilization step.
\newline
\hspace*{9mm}Stop after Create repository step): \href{https://docs.github.com/en/get-started/quickstart/create-a-repo}{Procedure}
\newline
\newline
Let's push the commit we made to the remote repository. First, we will point our local repo to the remote repo. Take your GitHub user name and replace \texttt{username} in the following command - then run it.
\newline
\newline
\centerline{\texttt{git remote add origin git@github.com:username/store.git}}
\newline
\newline
To see if the repository was updated, run \texttt{git remote -v} in your terminal. Now push your code to the remote repository (i.e. your remote master branch). Run the following:
\newline
\newline
\centerline{\texttt{git push origin master}}
\newline
\newline
Open up your \texttt{store} repo in GitHub. If your command was successful then you should see the \texttt{code.txt} file inside it.

\section{Basic Branching and Merging}
At this point, you have shared your work with others. Your local master branch is synched with the remote master branch. Your colleagues will clone your repository to their local machines using the \texttt{git clone} command. They will make changes, commit them to their local master branches and push them up to the repository that you just created. Git's strength is that it will track these changes. It also offers the tools to make sure that you don't overwrite anyone's work when you push up your own changes. We'll see how to do this now. Then we'll talk a little about branches. 
\newline
\newline
Let's mimic a colleague by cloning your remote repository to a different folder on your machine. Make sure this folder is outside of your existing \texttt{store} directory. Create a folder called \texttt{colleaguesrepository} and then navigate inside that folder using the terminal. Then run the following command (replacing \texttt{username} with your GitHub user name):
\newline
\newline
\centerline{\texttt{git clone git@github.com:username/store.git}}
\newline
\newline
When the command finishes, you should find another copy of the \texttt{store} directory downloaded. Create a file called \texttt{colleaguesfile.txt} in this new \texttt{store} directory. Then navigate inside the directory using the terminal. We will add, commit and push this file to our remote repo. Run the following: 
\newline

- \texttt{git add colleaguesfile.txt} 

- \texttt{git commit -m "I am a new colleague committing some new code"} 

- \texttt{git push origin master}
\newline
\newline
Ok, so our colleague has committed their changes. We have our own work to finish, and we need to push it to remote. So let's do that now. Use your terminal to navigate back to your \textbf{initial} \texttt{store} repository. Create a file in there called \texttt{mysecondfile.txt}. Then run the add, commit, push sequence of commands:
\newline

- \texttt{git add mysecondfile.txt} 

- \texttt{git commit -m "I am pushing up my work now"} 

- \texttt{git push origin master}
\newline
\newline
Now your push should be rejected. You will see a message like:
\newline
\newline
\texttt{\small
To github.com:username/store.git
\\
 ! [rejected]        master -> master (fetch first)
\\
error: failed to push some refs to 'git@github.com:username/store.git'
\\
hint: Updates were rejected because the remote contains work you dont
\\
hint: have locally. This is usually caused by another repository pushing
\\
hint: to the same ref. You may want to first integrate the remote changes
\\
hint: (e.g., 'git pull ...') before pushing again.
\\
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
}
\newline
This occurred because your remote repository has been updated with your colleague's work. This is how Git is useful. It will stop you from overwriting another person's work. Another mistake we made here was to commit our changes directly to local master. This is where branching strategy becomes important. You should always create a local branch from your local master. Then if your colleagues push to remote while you are working on your changes, you can pull their changes down to your local master. That way it always stays in synch with the remote master branch. When you're ready to push your own changes up, you can "merge" your changes into your updated local master and push it to remote. Let's do that now. Firstly let's undo the commit we just made. Run:
\newline
\newline\centerline{\texttt{git reset --hard HEAD{\raise.17ex\hbox{$\scriptstyle\mathtt{\sim}$}}1}}
\newline
\newline
If you run \texttt{git log} now, you will see that your most recent commit has been wiped from the Git version history. The file 
\texttt{mysecondfile.txt} is also gone. This is what a hard reset does. A soft reset \texttt{git reset --soft HEAD{\raise.17ex\hbox{$\scriptstyle\mathtt{\sim}$}}1} would undo the latest commit but keep the files associated with that commit (it will take you back in time to the point just before you made your last commit). We'll explore these poweruser commands in more detail later.
\newline
\newline
Let's create a new branch (we'll call it \texttt{first}) to make our changes on:
\newline
\newline\centerline{\texttt{git checkout -b first}}
\newline
\newline
If you run \texttt{git status} now you will see the output \texttt{On branch first}. If you run \texttt{git log} to see your commit history, you will see that you only have one commit. Your branch \texttt{first} is an exact copy of local master. You can switch between branches by running \texttt{git checkout branchname} replacing \texttt{branchname} with the name of the branch you want to switch to. As an excerise, switch now to \texttt{master} and examine your commit history, then switch back to the \texttt{first} branch. 
\newline
\newline
Now, let's commit some changes on the \texttt{first} branch. Afterwards, we will try to merge our changes to local master. Start by creating a file in the \texttt{store} repo called \texttt{mysecondfile.txt}. Then run the add and commit commands:
\newline

- \texttt{git add mysecondfile.txt} 

- \texttt{git commit -m "My first commit on a branch"} 
\newline
\newline
Run \texttt{git log} to check the commit was successful. Now let's push our changes to remote. The following is an overview of that flow:
\newline

- \texttt{Switch back to local master}

- \texttt{Get our colleagues changes from remote master}

- \texttt{Merge our changes into updated local master (2 commands)} 

- \texttt{Push our changes to remote master}
\newline
\newline
Here is the command flow:
\newline

- \texttt{git checkout master}

- \texttt{git pull origin master}

- \texttt{git merge --squash first} 

- \texttt{git commit -m "Commiting branch changes"}

- \texttt{git push origin master}
\newline
\newline
If you check your GitHub repository now, you should see that \texttt{mysecondfile.txt} is added to it. Now let's unpack what happened with the above commands.
\newline
\newline
The command \texttt{git pull origin master} was used to pull the remote changes down to our local master branch. You must be on the master branch to do this. You should always pull down the remote changes before you merge your work to local master. This ensures your master branches are always synched. 
\newline
\newline
Always switch to the branch you want to merge your changes into. We wanted to merge our work (i.e. the \texttt{first} branch) into master, so we ran our merge command while being on master. The \texttt{--squash} argument squashes multiple commits into one commit. That is why we had to run a second commit on the local master branch. It's good practice to squash your commits into one, because it makes it easier to read the commit version history when you run \texttt{git log}. You always give the name of the branch that has to be merged at the end of the command.

\section{Merge Conflicts}
In the last section, we had a merge that was straightforward. However, this does not happen often in the real world of big projects and multiple engineers. A colleague of yours might be working on the same files as you at any given moment, and may even be working on the same lines of text or code within those files. This can lead to Git throwing up a "merge conflict". You will have to resolve these conflicts before you can push your work to remote. We'll see see how this happens in this section, and you will learn how to fix it. 
\newline
\newline
We're going to pretend that our Boss has asked us to add our suggestions for improving team efficiency to \texttt{mysecondfile.txt}. Our Boss wants all the team's suggestions, because it's useful for an open discussion later. So let's pretend to be our colleague again. Navigate back to your colleagues \texttt{store} folder. Then pull the latest changes down to the master branch. Run \texttt{git log} afterward to make sure your colleague has got the changes you pushed up a few moments ago. We'll not create a branch this time (for brevity) but you can assume that your colleague would have branched off and gone through the merge process.
\newline
\newline
Open up the \texttt{mysecondfile.txt} and add the text \texttt{Have less meetings} on \textbf{line 1}. Make sure you only add the text to the first line. When you are happy with the changes, run the add, commit, push flow as usual:
\newline

- \texttt{git add mysecondfile.txt} 

- \texttt{git commit -m "My colleague is making another commit"} 

- \texttt{git push origin master}
\newline
\newline
Now navigate back to your \textbf{original} \texttt{store} folder using the terminal. Let's create another branch called \texttt{second}. Run:
\newline
\newline\centerline{\texttt{git checkout -b second}}
\newline
\newline 
Open the file \texttt{mysecondfile.txt} and add the text \texttt{Do more off site team building} on \textbf{line 1}. Then run the following commands to do the merge:
\newline

- \texttt{git checkout master}

- \texttt{git pull origin master}

- \texttt{git merge --squash second} 
\newline
\newline
You should see the following text:
\newline
\newline
\texttt{\small
Auto-merging mysecondfile.txt
\\
CONFLICT (content): Merge conflict in mysecondfile.txt
\\
Squash commit -- not updating HEAD
\\
Automatic merge failed; fix conflicts and then commit the result.
}
\newline
\newline
We need to fix the conflict that has arised. Here's what our text file \texttt{mysecondfile.txt} looks like now (PTO):
\newline
\newline
\newline
\newline
\newline
\texttt{\small
<<<<<<< HEAD
\\
Have less meetings
\\
=======
\\
Do more off site team building
\\
>>>>>>> second
}
\newline
\newline
The text between \texttt{HEAD} and \texttt{=======} is what is in the remote repo - what your colleague pushed up. The text below the \texttt{=======} is what is on your branch \texttt{second}. Since you and your colleague have been working on the same area of the same file, Git does not automatically know which edits to keep. In this case it's quite easy to decide what to keep - we want to save both. However, sometimes, it may not be immediately apparent what you need to keep (like in the case that your colleague is refactoring code, but you're working on that same code during the refactor). When this happens, you have to sit down with your colleague and see what needs to be kept. 
\newline
\newline
Ok, back to our current merge. We know that we want to keep both lines of text, so let's edit our file and resolve the conflicts with \texttt{git}. Open \texttt{mysecondfile.txt} and remove everything except the two sentences. Then save the file. On the command line, run the add command to resolve the conflict fully:
\newline
\newline\centerline{\texttt{git add mysecondfile.txt}}
\newline
\newline
Then run the usual flow to push up your changes:
\newline

- \texttt{git commit -m "Resolved some conflicts from my branch second"} 

- \texttt{git push origin master}
\newline
\newline

\section{Rebasing a branch}
In section Basic Branching and Merging, we saw a rather straight-forward merge. In the section Merge Conflicts, we saw how the merging process can become rather complicated. However, there are a number strategies to keep merging easy, especially when your working on a local branch for hours or days at a time. If you keep your local branch up to date while you're working on it, merging to master can be quite a painless process. In this section, we will see a process called rebasing, which will allow us to do just that.
\newline
\newline
Create a new branch (called \texttt{testrebase}) in your own \texttt{store} repo. Create a new file called \texttt{rebase.txt}, run the add and commit commands only. Run \texttt{git log} and examine the version history (take note of your most recent commit). 
\newline
\newline
Switch over to your colleagues \texttt{store} repo. Pull down the latest changes to local master. Again, we will not branch off. Create a file \texttt{anewfile.txt}, add it, commit it and push it to remote. Repeat this process with another file called \texttt{anotherfile.txt}. When you are done, you can check your version history to see the commits (remember this for when we do the rebase).
\newline
\newline
Okay, we are ready to do the rebase. Switch back to your own repo. Switch to the master branch and pull down the latest changes. Check the version history and compare them with the version history of your colleagues \texttt{store}. When you're ready, switch to your \texttt{testrebase} branch. Run the following command to rebase.
\newline
\newline\centerline{\texttt{git rebase master}}
\newline
\newline  
You should see the following message in your terminal
\newline
\newline
\texttt{\small
First, rewinding head to replay your work on top of it...
\\
Applying: rebase file
\\
}
\newline
Now if you run \texttt{git log} on your branch, you should see that your commit is at the top of the version history, with your colleague's commits underneath it. This is what a rebase does, it re-bases the changes on your branch against another branch (master in this case). That way, you can keep up to date while you are working on your changes.

\section{Stashing your changes}
During development of a new feature, you may be asked to fix a software defect. You may have just started work on the feature, and you have some changes, but you're not ready to commit them yet. You have to create a new branch and switch to it but you don't want to lose your work. This is where the \texttt{git stash} command comes in. We'll see an example of how to do this now.
\newline
\newline
Create a new branch called \texttt{stashexample}. Create a new file called \texttt{filetostash.txt}. Now run:
\newline
\newline\centerline{\texttt{git stash list}}
\newline
\newline
There should be no output in your terminal screen. That is because there is nothing in your stash. Run the following commands:
\newline

- \texttt{git add filetostash.txt}

- \texttt{git stash}
\newline
\newline
If you run \texttt{git stash list} now, you should see the following:
\newline
\newline
\texttt{\small
stash@\{0\}: WIP on stashexample: <last commit> <commit message>
\\
}
\newline
If you run \texttt{git status} now, you should see \texttt{nothing to commit} in your terminal. So at this point, you're free to move away to create another branch. But we'll stay on this branch - we can assume that we've fixed the software defect and now we have come back to continue our work. We want to get our changes out of stash. You can do this via running the \texttt{apply} command. You have to give it the id of the entry in the stash list (in our case, we only have one: \texttt{stash@\{0\}}). To retrieve the changes, run:
\newline
\newline\centerline{\texttt{git stash apply stash@\{0\}}}
\newline
\newline
If you run \texttt{git status} now, you should see \texttt{filetostash.txt} is being tracked again. 









\chapter{Advanced Git}

With the material you covered in Chapter 2, you now have enough knowledge to a) use Git in the workplace and b) explore the wider Git ecosystem. In this Chapter, we'll cover the topics that will set you up to be a poweruser.  

\section{Submodules}
\section{When do you rebase and when do you merge}
\section{Cherrypicking}












\end{document}



















